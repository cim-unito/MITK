/*===================================================================

The Medical Imaging Interaction Toolkit (MITK)

Copyright (c) German Cancer Research Center,
Division of Medical and Biological Informatics.
All rights reserved.

This software is distributed WITHOUT ANY WARRANTY; without
even the implied warranty of MERCHANTABILITY or FITNESS FOR
A PARTICULAR PURPOSE.

See LICENSE.txt or http://www.mitk.org for details.

===================================================================*/

#include "mitkPluginActivator.h"

#include "mitkLog.h"

#include <QString>
#include <QFileInfo>

#include "internal/mitkDataStorageService.h"

#include <mitkModuleRegistry.h>
#include <mitkModule.h>
#include <mitkModuleContext.h>
#include <mitkVtkLoggingAdapter.h>
#include <mitkItkLoggingAdapter.h>


namespace mitk
{

class ITKLightObjectToQObjectAdapter : public QObject
{

public:

  ITKLightObjectToQObjectAdapter(const QStringList& clazzes, itk::LightObject* service)
    : interfaceNames(clazzes), mitkService(service)
  {}

  // This method is called by the Qt meta object system. It is usually
  // generated by the moc, but we create it manually to be able to return
  // a MITK micro service object (derived from itk::LightObject). It basically
  // works as if the micro service class had used the Q_INTERFACES macro in
  // its declaration. Now we can successfully do a
  // qobject_cast<mitk::SomeMicroServiceInterface>(lightObjectToQObjectAdapter)
  void* qt_metacast(const char *_clname)
  {
    if (!_clname) return 0;
    if (!strcmp(_clname, "ITKLightObjectToQObjectAdapter"))
      return static_cast<void*>(const_cast<ITKLightObjectToQObjectAdapter*>(this));
    if (interfaceNames.contains(QString(_clname)))
      return static_cast<void*>(mitkService);
    return QObject::qt_metacast(_clname);
  }

private:

  QStringList interfaceNames;
  itk::LightObject* mitkService;
};

const std::string org_mitk_core_services_Activator::PLUGIN_ID = "org.mitk.core.services";

void org_mitk_core_services_Activator::start(ctkPluginContext* context)
{
  pluginContext = context;

  //initialize logging
  mitk::LoggingBackend::Register();
  QString filename = "mitk.log";
  QFileInfo path = context->getDataFile(filename);
  mitk::LoggingBackend::SetLogFile(path.absoluteFilePath().toStdString().c_str());
  mitk::VtkLoggingAdapter::Initialize();
  mitk::ItkLoggingAdapter::Initialize();

  //initialize data storage service
  DataStorageService* service = new DataStorageService();
  dataStorageService = IDataStorageService::Pointer(service);
  context->registerService<mitk::IDataStorageService>(service);

  // Get the MitkCore Module Context
  mitkContext = mitk::ModuleRegistry::GetModule(1)->GetModuleContext();

  // Process all already registered services
  std::list<mitk::ServiceReference> refs = mitkContext->GetServiceReferences("");
  for (std::list<mitk::ServiceReference>::const_iterator i = refs.begin();
       i != refs.end(); ++i)
  {
    this->AddMitkService(*i);
  }

  mitkContext->AddServiceListener(this, &org_mitk_core_services_Activator::MitkServiceChanged);
}

void org_mitk_core_services_Activator::stop(ctkPluginContext* /*context*/)
{
  mitkContext->RemoveServiceListener(this, &org_mitk_core_services_Activator::MitkServiceChanged);

  foreach(ctkServiceRegistration reg, mapMitkIdToRegistration.values())
  {
    reg.unregister();
  }
  mapMitkIdToRegistration.clear();

  qDeleteAll(mapMitkIdToAdapter);
  mapMitkIdToAdapter.clear();

  //clean up logging
  mitk::LoggingBackend::Unregister();

  dataStorageService = 0;
  mitkContext = 0;
  pluginContext = 0;
}

void org_mitk_core_services_Activator::MitkServiceChanged(const mitk::ServiceEvent event)
{
  switch (event.GetType())
  {
  case mitk::ServiceEvent::REGISTERED:
  {
    this->AddMitkService(event.GetServiceReference());
    break;
  }
  case mitk::ServiceEvent::UNREGISTERING:
  {
    long mitkServiceId = mitk::any_cast<long>(event.GetServiceReference().GetProperty(mitk::ServiceConstants::SERVICE_ID()));
    ctkServiceRegistration reg = mapMitkIdToRegistration.take(mitkServiceId);
    if (reg)
    {
      reg.unregister();
    }
    delete mapMitkIdToAdapter.take(mitkServiceId);
    break;
  }
  case mitk::ServiceEvent::MODIFIED:
  {
    long mitkServiceId = mitk::any_cast<long>(event.GetServiceReference().GetProperty(mitk::ServiceConstants::SERVICE_ID()));
    ctkDictionary newProps = CreateServiceProperties(event.GetServiceReference());
    mapMitkIdToRegistration[mitkServiceId].setProperties(newProps);
    break;
  }
  default:
    break; // do nothing
  }
}

void org_mitk_core_services_Activator::AddMitkService(const mitk::ServiceReference& ref)
{
  // Get the MITK micro service object
  itk::LightObject* mitkService = mitkContext->GetService(ref);
  if (mitkService == 0) return;

  // Get the interface names against which the service was registered
  std::list<std::string> clazzes =
      mitk::any_cast<std::list<std::string> >(ref.GetProperty(mitk::ServiceConstants::OBJECTCLASS()));

  QStringList qclazzes;
  for(std::list<std::string>::const_iterator clazz = clazzes.begin();
      clazz != clazzes.end(); ++clazz)
  {
    qclazzes << QString::fromStdString(*clazz);
  }

  long mitkServiceId = mitk::any_cast<long>(ref.GetProperty(mitk::ServiceConstants::SERVICE_ID()));

  QObject* adapter = new ITKLightObjectToQObjectAdapter(qclazzes, mitkService);
  mapMitkIdToAdapter[mitkServiceId] = adapter;

  ctkDictionary props = CreateServiceProperties(ref);
  mapMitkIdToRegistration[mitkServiceId] = pluginContext->registerService(qclazzes, adapter, props);
}

ctkDictionary org_mitk_core_services_Activator::CreateServiceProperties(const ServiceReference &ref)
{
  ctkDictionary props;

  long mitkServiceId = mitk::any_cast<long>(ref.GetProperty(mitk::ServiceConstants::SERVICE_ID()));
  props.insert("mitk.serviceid", QVariant::fromValue(mitkServiceId));

  // Add all other properties from the MITK micro service
  std::vector<std::string> keys;
  ref.GetPropertyKeys(keys);
  for (std::vector<std::string>::const_iterator it = keys.begin(); it != keys.end(); ++it)
  {
    QString key = QString::fromStdString(*it);
    mitk::Any value = ref.GetProperty(*it);
    // We cannot add any mitk::Any object, we need to query the type
    const std::type_info& objType = value.Type();
    if (objType == typeid(std::string))
    {
      props.insert(key, QString::fromStdString(ref_any_cast<std::string>(value)));
    }
    else if (objType == typeid(std::vector<std::string>))
    {
      const std::vector<std::string>& list = ref_any_cast<std::vector<std::string> >(value);
      QStringList qlist;
      for (std::vector<std::string>::const_iterator str = list.begin();
           str != list.end(); ++str)
      {
         qlist << QString::fromStdString(*str);
      }
      props.insert(key, qlist);
    }
    else if (objType == typeid(std::list<std::string>))
    {
      const std::list<std::string>& list = ref_any_cast<std::list<std::string> >(value);
      QStringList qlist;
      for (std::list<std::string>::const_iterator str = list.begin();
           str != list.end(); ++str)
      {
         qlist << QString::fromStdString(*str);
      }
      props.insert(key, qlist);
    }
    else if (objType == typeid(char))
    {
      props.insert(key, QChar(ref_any_cast<char>(value)));
    }
    else if (objType == typeid(unsigned char))
    {
      props.insert(key, QChar(ref_any_cast<unsigned char>(value)));
    }
    else if (objType == typeid(bool))
    {
      props.insert(key, any_cast<bool>(value));
    }
    else if (objType == typeid(short))
    {
      props.insert(key, any_cast<short>(value));
    }
    else if (objType == typeid(unsigned short))
    {
      props.insert(key, any_cast<unsigned short>(value));
    }
    else if (objType == typeid(int))
    {
      props.insert(key, any_cast<int>(value));
    }
    else if (objType == typeid(unsigned int))
    {
      props.insert(key, any_cast<unsigned int>(value));
    }
    else if (objType == typeid(float))
    {
      props.insert(key, any_cast<float>(value));
    }
    else if (objType == typeid(double))
    {
      props.insert(key, any_cast<double>(value));
    }
    else if (objType == typeid(long long int))
    {
      props.insert(key, any_cast<long long int>(value));
    }
    else if (objType == typeid(unsigned long long int))
    {
      props.insert(key, any_cast<unsigned long long int>(value));
    }
  }

  return props;
}

org_mitk_core_services_Activator::org_mitk_core_services_Activator()
  : mitkContext(0), pluginContext(0)
{
}

}

Q_EXPORT_PLUGIN2(org_mitk_core_services, mitk::org_mitk_core_services_Activator)
